#!/usr/local/bin/perl -w

# $Header: /home/kst/calc/calc,v 1.28 1997-09-14 17:28:31-07 kst Exp $

#
# Currently valid @stack runs from 1 to $#stack inclusive.
# Index 0 is not used (and is set to 'BOTTOM').
#

use strict;
use subs qw( Usage Debug Dump Show_Vars Is_Numeric Is_HMS From_HMS To_HMS
             Is_Hex Help Check Evaluate Evaluate_Line Factorial );
use vars qw( $prog_name $opt_d $opt_h $Debugging
	     @stack %reserved %variables
	     $degrees_to_radians $ofmt $inhibit_dump );
use Getopt::Std;

($prog_name = $0) =~ s(.*/)();

getopts 'dh' or Usage;
Usage if defined $opt_h;
$Debugging = defined $opt_d;

@stack = qw(BOTTOM);

#
# Note: The quotes are necessary here, since many of the names are
#       reserved words.
#
%reserved = ( 'acos'   => 1,
	      'acos'   => 1,
	      'asin'   => 1,
	      'atan'   => 1,
	      'atan2'  => 1,
	      'clear'  => 1,
	      'cos'    => 1,
	      'deg'    => 1,
	      'depth'  => 1,
	      'drop'   => 1,
	      'dropn'  => 1,
	      'dup'    => 1,
	      'exp'    => 1,
	      'help'   => 1,
	      'hex'    => 1,
	      'Hex'    => 1,
	      'hms'    => 1,
	      'HMS'    => 1,
	      'int'    => 1,
	      'ln'     => 1,
	      'log'    => 1,
	      'octal'  => 1,
	      'Octal'  => 1,
	      'ofmt'   => 1,
	      'rand'   => 1,
	      'sin'    => 1,
	      'sqrt'   => 1,
	      'srand'  => 1,
	      'srandx' => 1,
	      'swap'   => 1,
	      'tan'    => 1,
	      'vars'   => 1 );

$variables{pi} = 3.14159265358979323846;
$variables{e}  = 2.71828182845904523536;

$degrees_to_radians = $variables{pi} / 180.0;

$ofmt = '%.16g';

if (@ARGV) {
    Evaluate_Line join ' ', @ARGV;
}
else {
    while (<>) {
        chomp;
        Evaluate_Line $_;
    }
}

########################################################################

sub Dump {
    my($base) = @_;

    my $i;
    my $format;

    if ($base eq 'HMS') {
	$format = "%3d: %s\n";
    }
    else {
	$format = "%3d: $ofmt\n" if $base == 10;
	$format = "%3d: 0x%x\n"  if $base == 16;
	$format = "%3d: 0%o\n"   if $base ==  8;
    }

    if ($#stack) {
        for ($i = 1; $i <= $#stack; $i ++) {
            # printf("%3d: %s\n", $i, $stack[$i]);
	    if ($base eq 'HMS') {
		printf $format, $i, To_HMS $stack[$i];
	    }
	    else {
		printf $format, $i, $stack[$i];
	    }
        }
    }
    else {
        print "  <empty stack>\n";
    }
} # Dump

sub Show_Vars {
    foreach my $name (sort keys %variables) {
        printf "%-8s = $ofmt\n", $name, $variables{$name};
    }
} # Show_Vars

sub Is_Numeric {
    my $arg = $_[0];
    my $warning = undef;
    {
        local $SIG{__WARN__} = sub { $warning = $_[0] };
        my $tmp = $arg + 0;
    }
    if (defined $warning) {
        if ($warning =~ /numeric/) {
            return 0; # non-numeric
        }
        else {
            warn $warning; # some other warning (?)
	    return 0;
        }
    }
    else {
        return 1; # numeric
    }
} # Is_Numeric

sub Is_HMS {
    my($word) = @_;

    return $word =~ /^(\d+:)+\d+$/;
} # Is_HMS

sub From_HMS {
    my($word) = @_;
    my @fields;
    my $result = 0.0;

    @fields = split /:/, $word;

    for (my $i = $#fields; $i >= 0; $i --) {
	$result += $fields[$i];
	$result /= 60.0 if $i > 0;
    }
    return $result;
} # From_HMS

sub To_HMS {
    return "To_HMS not yet implemented";
} # To_HMS

sub Is_Hex {
    my($word) = @_;

    return $word =~ /^0x[\da-f]/i;
} # Is_Hex

sub Help {
    print <<'EOF';
    +, -, *, /, %, ** : arithmetic operators
    --                : negate
    //                : reciprocal
    %%                : / and %
    & | ^ ~ << >>     : logical operators
    dup               : duplicate top of stack (tos)
    drop              : drop tos
    dropn             : drop tos+1 items from stack
    clear             : clear stack
    swap              : swap top two stack elements
    sin, cos, tan, asin, acos, atan :
                        trig functions (radians)
    atan2             : atan(y/x)
    deg               : convert degrees->radians
    exp               : e**x
    ln,  loge         : log base e
    log, log10        : log base 10
    lg,  log2         : log base 2
    int               : integer part (truncate towards 0)
    srand             : set random seed
    srandx            : set random seed to specified value
    rand              : random number
    sqrt              : square root
    vars              : show all variables
    <name>=           : assign variable
    ofmt=             : show output format
    ofmt=<fmt>        : set output format
    .                 : display tos
    hex               : display tos in hex
    octal             : display tos in octal
    hms               : display tos in H:M:S format
    ,                 : dump stack
    Hex               : dump stack in hex
    Octal             : dump stack in octal
    HMS               : dump stack in H:M:S format
    \                 : inhibit stack dump
EOF
#   print "    ...          : continue (used on command line)"
} # Help

sub Check {
    my($word, $count) = @_;

    if ($#stack >= $count) {
        return 1;
    }
    else {
        warn "$word error: too few arguments\n";
        return 0;
    }
} # Check

sub Evaluate {
    my($word) = @_;

    Debug "DEBUG: evaluate \"$word\"\n";

    if ($word eq 'dup') {
        Check $word, 1 and push @stack, $stack[$#stack];
    }

    elsif ($word eq 'drop') {
        Check $word, 1 and pop @stack;
    }

    elsif ($word eq 'dropn') {
        Check $word, 1 and do {
	    if ($#stack >= $stack[$#stack] + 1) {
		$#stack -= $stack[$#stack] + 1;
	    }
	    else {
		warn "$word error: too few arguments\n";
	    }
	};
    }

    elsif ($word eq 'clear') {
        $#stack = 0;
    }

    elsif ($word eq 'depth') {
        push @stack, $#stack;
    }

    elsif ($word eq 'swap') {
        Check $word, 2 and do {
            my($temp1, $temp2) = (pop @stack, pop @stack);
            push @stack, $temp1;
            push @stack, $temp2;
        };
    }

    elsif ($word eq '+') {
        Check $word, 2 and do {
            push @stack, pop(@stack) + pop(@stack);
        };
    }

    elsif ($word eq '-') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x - $y;
        };
    }

    elsif ($word eq '*') {
        Check $word, 2 and do {
            push @stack, pop(@stack) * pop(@stack);
        };
    }

    elsif ($word eq '/') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x / $y;
        };
    }

    elsif ($word eq '%') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x % $y;
        };
    }

    elsif ($word eq '**') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x ** $y;
        };
    }

    elsif ($word eq '--') {
        Check $word, 1 and push @stack, - pop @stack;
    }

    elsif ($word eq '//') {
        Check $word, 1 and push @stack, 1.0 / pop @stack;
    }

    elsif ($word eq '%%') {
        if (Check $word, 2) {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, int($x / $y), $x % $y;
        }
    }

    #
    # For logical operators, add 0 to each operand to ensure they
    # operate on numbers, not strings.
    #

    elsif ($word eq '&') {
	Check $word, 2 and push @stack, (0 + pop @stack) & (0 + pop @stack);
    }

    elsif ($word eq '|') {
	Check $word, 2 and push @stack, (0 + pop @stack) | (0 + pop @stack);
    }

    elsif ($word eq '^') {
	Check $word, 2 and push @stack, (0 + pop @stack) ^ (0 + pop @stack);
    }

    elsif ($word eq '~') {
	Check $word, 1 and push @stack, ~ (0 + pop @stack);
    }

    elsif ($word eq '<<') {
	Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) << (0 + $y);
	}
    }

    elsif ($word eq '>>') {
	Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) >> (0 + $y);
	}
    }

    elsif ($word eq 'sin') {
        Check $word, 1 and push @stack, sin pop @stack;
    }

    elsif ($word eq 'cos') {
        Check $word, 1 and push @stack, cos pop @stack;
    }

    elsif ($word eq 'tan') {
        Check $word, 1 and do {
            my($x) = pop @stack;
            push @stack, sin $x / cos $x;
        };
    }

    elsif ($word eq 'asin') {
        Check $word, 1 and do {
            my($x) = pop @stack;
            push @stack, atan2($x, sqrt(1 - $x**2));
        };
    }

    elsif ($word eq 'acos') {
        Check $word, 1 and do {
            my($x) = pop @stack;
            push @stack, atan2(sqrt(1 - $x**2), $x);
        };
    }

    elsif ($word eq 'atan') {
        Check $word, 1 and push @stack, atan2(pop @stack, 1.0);
    }

    elsif ($word eq 'atan2') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, atan2($x, $y);
        };
    }

    elsif ($word eq 'deg') {
	Check $word, 1 and push @stack, pop(@stack) * $degrees_to_radians;
    }

    elsif ($word eq 'exp') {
        Check $word, 1 and push @stack, exp pop @stack;
    }

    elsif ($word eq 'ln' or $word eq 'loge') {
        Check $word, 1 and push @stack, log pop @stack;
    }

    elsif ($word eq 'log' or $word eq 'log10') {
        Check $word, 1 and push @stack, log(pop @stack) / log 10.0;
    }

    elsif ($word eq 'lg' or $word eq 'log2') {
        Check $word, 1 and push @stack, log(pop @stack) / log 2.0;
    }

    elsif ($word eq 'int') {
        Check $word, 1 and push @stack, int pop @stack;
    }

    elsif ($word eq 'srandx') {
        Check $word, 1 and srand pop @stack;
    }

    elsif ($word eq 'srand') {
        srand(time^$$);
    }

    elsif ($word eq 'rand') {
        push @stack, rand;
    }

    elsif ($word eq 'randx') {
        Check $word, 1 and push @stack, rand pop @stack;
    }

    elsif ($word eq 'sqrt') {
        Check $word, 1 and push @stack, sqrt pop @stack;
    }

    elsif ($word eq '!') {
        Check $word, 1 and push @stack, Factorial pop @stack;
    }

    elsif ($word eq 'vars') {
        Show_Vars;
    }

    elsif ( $word =~ /^ofmt=$/ ) {
        print qq("output format = "$ofmt"\n);
    }

    elsif ( $word =~ /^ofmt=(.*)$/ ) {
        $ofmt = $1;
    }

    elsif ($word =~ /^(.*)=$/) {
        my($var_name) = $1;
        if (defined $reserved{$var_name}) {
            print "= error: reserved name\n";
        } else {
            Check $word, 1 and $variables{$var_name} = pop @stack;
        }
    }

    elsif (defined $variables{$word}) {
        push @stack, $variables{$word};
    }

    elsif ($word eq '?' or $word eq 'help') {
        Help;
        $inhibit_dump = 1;
    }

    elsif ($word eq '.') {
        Check $word, 1 and do {
            printf "$ofmt\n", pop @stack;
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'hex') {
        Check $word, 1 and do {
            printf "0x%x\n", int $stack[$#stack];
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'octal') {
        Check $word, 1 and do {
            #
            # Workaround for mysterious bug, drops '0' and newline
            #
            # print "0", sprintf("%o", int(pop(@stack))), "\n";
            # Commented out workaround; no longer needed
            printf "0%o\n", int $stack[$#stack];
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'hms') {
        Check $word, 1 and do {
	    print To_HMS($stack[$#stack]), "\n";
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq ',') {
        Dump 10;
    }

    elsif ($word eq 'Hex') {
        Dump 16;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'HMS') {
        Dump 'HMS';
    }

#   else if (word == "...") {
#       Continue = 1
#   }

    elsif ($word eq '\\') {
        $inhibit_dump = 1;
    }

    elsif (Is_Numeric $word) {
        push @stack, $word;
    }

    elsif (Is_HMS $word) {
	push @stack, From_HMS $word;
    }

    elsif (Is_Hex $word) {
	push @stack, hex $word;
    }

    else {
        print STDERR "error: unrecognized word $word\n";
    }
} #  end Evaluate

sub Evaluate_Line {
    my($line) = @_;
    my $last_arg;

    Debug "DEBUG: evaluate_line \"$line\"\n";
    $inhibit_dump = 0;

    foreach my $arg (split /\s+/, $line) {
        $last_arg = $arg;
        Debug "DEBUG: calling evaluate \"$arg\"\n";
        Evaluate $arg;
    }
    if ($last_arg ne "," and not $inhibit_dump) {
        Dump 10;
    }
} # Evaluate_Line

sub Factorial {
    my($x) = @_;

    if ($x != int $x) {
	warn "Factorial requires an integer argument\n";
	return $x;
    }
    elsif ($x < 0) {
	warn "Factorial requires a non-negative argument\n";
	return $x;
    }
    else {
	my($result) = 1;
	for (my $i = 2; $i <= $x; $i ++) {
	    $result *= $i;
	}
	return $result;
    }
} # Factorial

sub Debug {
    print @_ if $Debugging;
} # Debug

sub Usage {
    print @_ if @_;
    print <<"EOF";
Usage: $prog_name [options] [RPN expr]
    -h : Help
    -d : Debugging
Commands:
EOF
    Help;
    exit 1;
} # Usage
