#!/usr/local/bin/perl -w

# $Header: /home/kst/calc/calc,v 1.20 1997-03-23 03:10:44-08 kst Exp $

#
# Currently valid @stack runs from 1 to $#stack inclusive;
# Index 0 is not used (and is set to 'BOTTOM')
#

use subs qw(Dump Show_Vars Is_Numeric Is_HMS From_HMS To_HMS Is_Hex Help Check
	    Evaluate Evaluate_Line Factorial);

$debugging = defined $ENV{DEBUG};

@stack = qw(BOTTOM);

%reserved = ( 'acos'   => 1,
              'acos'   => 1,
              'asin'   => 1,
              'atan'   => 1,
              'atan2'  => 1,
              'clear'  => 1,
              'cos'    => 1,
              'deg'    => 1,
              'depth'  => 1,
              'drop'   => 1,
              'dup'    => 1,
              'exp'    => 1,
              'help'   => 1,
              'hex'    => 1,
              'Hex'    => 1,
              'hms'    => 1,
              'HMS'    => 1,
              'int'    => 1,
              'ln'     => 1,
              'log'    => 1,
              'octal'  => 1,
              'Octal'  => 1,
              'ofmt'   => 1,
              'rand'   => 1,
              'sin'    => 1,
              'sqrt'   => 1,
              'srand'  => 1,
              'srandx' => 1,
              'swap'   => 1,
              'tan'    => 1,
              'vars'   => 1 );

$variables{'pi'} = 3.14159265358979323846;
$variables{'e'}  = 2.71828182845904523536;

$degrees_to_radians = $variables{'pi'} / 180.0;

$ofmt = '%.16g';

if (@ARGV) {
    Evaluate_Line join ' ', @ARGV;
}  else {
    while (<>) {
        chomp;
        Evaluate_Line $_;
    }
}

########################################################################

## sub pop {
##     pop @stack;
## } # end sub pop

## sub push {
##     local($item) = @_;
##     push(@stack, $item);
## } # end sub push

sub Dump {
    my($base) = @_;

    my $i;
    my $format;

    if ($base eq 'HMS') {
	$format = "%3d: %s\n";
    }
    else {
	$format = "%3d: $ofmt\n" if $base == 10;
	$format = "%3d: 0x%x\n"  if $base == 16;
	$format = "%3d: 0%o\n"   if $base ==  8;
    }

    if ($#stack) {
        for ($i = 1; $i <= $#stack; $i ++) {
            # printf("%3d: %s\n", $i, $stack[$i]);
	    if ($base eq 'HMS') {
		printf $format, $i, To_HMS $stack[$i];
	    }
	    else {
		printf $format, $i, $stack[$i];
	    }
        }
    }
    else {
        print "  <empty stack>\n";
    }
} # end Dump

sub Show_Vars {
    foreach $name (sort keys %variables) {
        printf "%-8s = $ofmt\n", $name, $variables{$name};
    }
} # end Show_Vars

sub Is_Numeric {
    my($word) = @_;

    return $word =~ /^([+-]?)(\d*)(\.(\d*))?([Ee]([+-]?\d+))?$/ && "$2$4" ne '';
} # end Is_Numeric

sub Is_HMS {
    my($word) = @_;

    return $word =~ /^(\d+:)+\d+$/;
} # end Is_HMS

sub From_HMS {
    my($word) = @_;
    my @fields;
    my $result = 0.0;

    @fields = split /:/, $word;

    for ($i = $#fields; $i >= 0; $i --) {
	$result += $fields[$i];
	$result /= 60.0 if $i > 0;
    }
    return $result;
} # end From_HMS

sub To_HMS {
    return "To_HMS not yet implemented";
} # end To_HMS

sub Is_Hex {
    my($word) = @_;

    return $word =~ /^0x[\da-f]/i;
} # end Is_Hex

sub Help {
    print <<'EOF';
    +, -, *, /, %, ** : arithmetic operators
    --                : negate
    //                : reciprocal
    %%                : / and %
    dup               : duplicate top of stack (tos)
    drop              : drop tos
    clear             : clear stack
    swap              : swap top two stack elements
    sin, cos, tan, asin, acos, atan :
                        trig functions (radians)
    atan2             : atan(y/x)
    deg               : convert degrees->radians
    exp               : e^x
    ln,  loge         : log base e
    log, log10        : log base 10
    lg,  log2         : log base 2
    int               : integer part (truncate towards 0)
    srand             : set random seed
    srandx            : set random seed to specified value
    rand              : random number
    sqrt              : square root
    vars              : show all variables
    <name>=           : assign variable
    ofmt=             : show output format
    ofmt=<fmt>        : set output format
    .                 : display tos
    hex               : display tos in hex
    octal             : display tos in octal
    hms               : display tos in H:M:S format
    ,                 : dump stack
    Hex               : dump stack in hex
    Octal             : dump stack in octal
    HMS               : dump stack in H:M:S format
    \\                 : inhibit stack dump
EOF
#   print "    ...          : continue (used on command line)"
} # end Help

sub Check {
    my($count) = @_;

    if ($#stack >= $count) {
        return 1;
    } else {
        warn "$word error: too few arguments\n";
        return 0;
    }
} # end Check

sub Evaluate {
    # local($word) = @_;
    ($word) = @_;       # not local, used by Check

    print "DEBUG: evaluate \"$word\"\n" if $debugging;

    if ($word eq 'dup') {
        Check 1 and push @stack, $stack[$#stack];
    }

    elsif ($word eq 'drop') {
        Check 1 and pop @stack;
    }

    elsif ($word eq 'clear') {
        $#stack = 0;
    }

    elsif ($word eq 'depth') {
        push @stack, $#stack;
    }

    elsif ($word eq 'swap') {
        Check 2 and do {
            my($temp1, $temp2) = (pop @stack, pop @stack);
            push @stack, $temp1;
            push @stack, $temp2;
        }
    }

    elsif ($word eq '+') {
        Check 2 and do {
            push @stack, pop(@stack) + pop(@stack);
        }
    }

    elsif ($word eq '-') {
        Check 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x - $y;
        }
    }

    elsif ($word eq '*') {
        Check 2 and do {
            push @stack, pop(@stack) * pop(@stack);
        }
    }

    elsif ($word eq '/') {
        Check 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x / $y;
        }
    }

    elsif ($word eq '%') {
        Check 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x % $y;
        }
    }

    elsif ($word eq '**') {
        Check 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x ** $y;
        }
    }

    elsif ($word eq '^') {
        warn "error: use ** for exponentiation\n";
    }

    elsif ($word eq '--') {
        Check 1 and push @stack, - pop @stack;
    }

    elsif ($word eq '//') {
        Check 1 and push @stack, 1.0 / pop @stack;
    }

    elsif ($word eq '%%') {
        if (Check 2) {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, int($x / $y), $x % $y;
        }
    }

    elsif ($word eq 'sin') {
        Check 1 and push @stack, sin pop @stack;
    }

    elsif ($word eq 'cos') {
        Check 1 and push @stack, cos pop @stack;
    }

    elsif ($word eq 'tan') {
        Check 1 and do {
            my($x) = pop @stack;
            push @stack, sin $x / cos $x;
        }
    }

    elsif ($word eq 'asin') {
        Check 1 and do {
            my($x) = pop @stack;
            push @stack, atan2($x, sqrt(1 - $x**2));
        }
    }

    elsif ($word eq 'acos') {
        Check 1 and do {
            my($x) = pop @stack;
            push @stack, atan2(sqrt(1 - $x**2), $x);
        }
    }

    elsif ($word eq 'atan') {
        Check 1 and push @stack, atan2(pop @stack, 1.0);
    }

    elsif ($word eq 'atan2') {
        Check 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, atan2($x, $y);
        }
    }

    elsif ($word eq 'deg') {
	Check 1 and push @stack, pop(@stack) * $degrees_to_radians;
    }

    elsif ($word eq 'exp') {
        Check 1 and push @stack, exp pop @stack;
    }

    elsif ($word eq 'ln' or $word eq 'loge') {
        Check 1 and push @stack, log pop @stack;
    }

    elsif ($word eq 'log' or $word eq 'log10') {
        Check 1 and push @stack, log(pop @stack) / log 10.0;
    }

    elsif ($word eq 'lg' or $word eq 'log2') {
        Check 1 and push @stack, log(pop @stack) / log 2.0;
    }

    elsif ($word eq 'int') {
        Check 1 and push @stack, int pop @stack;
    }

    elsif ($word eq 'srandx') {
        Check 1 and srand pop @stack;
    }

    elsif ($word eq 'srand') {
        srand time^$$;
    }

    elsif ($word eq 'rand') {
        push @stack, rand;
    }

    elsif ($word eq 'randx') {
        Check 1 and push @stack, rand pop @stack
    }

    elsif ($word eq 'sqrt') {
        Check 1 and push @stack, sqrt pop @stack;
    }

    elsif ($word eq '!') {
        Check 1 and push @stack, Factorial pop @stack;
    }

    elsif ($word eq 'vars') {
        Show_Vars;
    }

    elsif ( $word =~ /^ofmt=$/ ) {
        print qq("output format = "$ofmt"\n);
    }

    elsif ( $word =~ /^ofmt=(.*)$/ ) {
        $ofmt = $1;
    }

    elsif ($word =~ /^(.*)=$/) {
        my($var_name) = $1;
        if (defined $reserved{$var_name}) {
            print "= error: reserved name\n";
        } else {
            Check 1 and $variables{$var_name} = pop @stack;
        }
    }

    elsif (defined $variables{$word}) {
        push @stack, $variables{$word};
    }

    elsif ($word eq '?' or $word eq 'help') {
        Help;
        $inhibit_dump = 1;
    }

    elsif ($word eq '.') {
        Check 1 and do {
            printf "$ofmt\n", pop @stack;
            $inhibit_dump = 1;
        }
    }

    elsif ($word eq 'hex') {
        Check 1 and do {
            printf "0x%x\n", int $stack[$#stack];
            $inhibit_dump = 1;
        }
    }

    elsif ($word eq 'octal') {
        Check 1 and do {
            #
            # Workaround for mysterious bug, drops '0' and newline
            #
            # print "0", sprintf("%o", int(pop(@stack))), "\n";
            # Commented out workaround; no longer needed
            printf "0%o\n", int $stack[$#stack];
            $inhibit_dump = 1;
        }
    }

    elsif ($word eq 'hms') {
        Check 1 and do {
	    print To_HMS($stack[$#stack]), "\n";
            $inhibit_dump = 1;
        }
    }

    elsif ($word eq ',') {
        Dump 10;
    }

    elsif ($word eq 'Hex') {
        Dump 16;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'HMS') {
        Dump 'HMS';
    }

#   else if (word == "...") {
#       Continue = 1
#   }

    elsif ($word eq '\\') {
        $inhibit_dump = 1;
    }

    elsif (Is_Numeric $word) {
        push @stack, $word;
    }

    elsif (Is_HMS $word) {
	push @stack, From_HMS $word;
    }

    elsif (Is_Hex $word) {
	push @stack, hex $word;
    }

    else {
        print STDERR "error: unrecognized word $word\n";
    }
} #  end Evaluate

sub Evaluate_Line {
    my($line) = @_;

    print "DEBUG: evaluate_line \"$line\"\n" if $debugging;
    $inhibit_dump = 0;

    foreach $arg (split /\s+/, $line) {
        $last_arg = $arg;
        print "DEBUG: calling evaluate \"$arg\"\n" if $debugging;
        Evaluate $arg;
    }
    if ($last_arg ne "," and not $inhibit_dump) {
        Dump 10;
    }
} # end Evaluate_Line

sub Factorial {
    my($x) = @_;

    if ($x != int $x) {
	warn "Factorial requires an integer argument\n";
	return $x;
    }
    elsif ($x < 0) {
	warn "Factorial requires a positive argument\n";
	return $x;
    }
    else {
	my($result) = 1;
	for ($i = 2; $i <= $x; $i ++) {
	    $result *= $i;
	}
	return $result;
    }
}
