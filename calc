#!/usr/bin/perl

# $Id: calc,v 1.54 2009-09-07 11:08:24-07 kst Exp $
# $Source: /home/kst/calc/calc,v $

#
# Currently valid @stack runs from 1 to $#stack inclusive.
# Index 0 is not used (and is set to 'BOTTOM').
#

use strict;
use warnings;

use Getopt::Long ();
use File::Spec ();

eval 'use Math::BigFloat';
my($Have_BigFloat) = ( $@ eq '' );

sub Usage(@);
sub Debug(@);
sub Image($);
sub Factorial($);
sub Help();
sub Check($$);
sub Check_Numeric($$);
sub Evaluate($);
sub Evaluate_String($);
sub Evaluate_Line($);
sub Dump($);
sub Show_Vars();
sub Is_Numeric($);
sub Is_HMS($);
sub From_HMS($);
sub To_HMS($);
sub Is_Hex($);
sub De_Comma($);

my $Program_Name = (File::Spec->splitpath($0))[2];

my %Opt = ();
my @Opts = ( \%Opt, qw( debugging!
                        help! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $Opt{help};

my $inhibit_dump = 0;

my @stack = qw(BOTTOM);

my @reserved = qw( acos asin atan atan2 clear cos deg depth drop dropn
                   dup exp help hex Hex hms HMS int ln log octal Octal
                   ofmt rand sin sqrt srand srandx sumn swap tan vars );
my %reserved = map { $_ => 1 } @reserved;

my %variables = ( pi => abs atan2(0, -1),
                  e  => exp 1,
                  k  => 2**10,
                  M  => 2**20,
                  G  => 2**30,
                  T  => 2**40,
                  P  => 2**50 );
my $degrees_to_radians = $variables{pi} / 180.0;
my $ofmt = '%.16g';

if (@ARGV) {
    Evaluate_Line join ' ', @ARGV;
}
else {
    while (<>) {
        chomp;
        Evaluate_Line $_;
    }
}

########################################################################

sub Dump($) {
    my($base) = @_;

    my $i;
    my $format;

    if ($base eq 'HMS') {
        $format = "%3d: %s\n";
    }
    else {
        $format = "%3d: $ofmt\n" if $base == 10;
        $format = "%3d: 0x%x\n"  if $base == 16;
        $format = "%3d: 0%o\n"   if $base ==  8;
    }

    if ($#stack) {
        for ($i = 1; $i <= $#stack; $i ++) {
            # printf("%3d: %s\n", $i, $stack[$i]);
            if (ref $stack[$i] eq 'Math::BigFloat') {
                printf "%3d: ", $i;
                print "B: $stack[$i]\n";
            }
            elsif (ref $stack[$i] eq 'SCALAR') {
                printf "%3d: \"%s\"\n", $i, ${$stack[$i]};
            }
            elsif ($base eq 'HMS') {
                printf $format, $i, To_HMS $stack[$i];
            }
            else {
                printf $format, $i, $stack[$i];
            }
        }
    }
    else {
        print "  <empty stack>\n";
    }
} # Dump

# ----------------------------------------------------------------------

sub Show_Vars() {
    foreach my $name (sort keys %variables) {
        printf "%-8s = $ofmt\n", $name, $variables{$name};
    }
} # Show_Vars

# ----------------------------------------------------------------------

sub Is_Numeric($) {
    my $arg = $_[0];
    return 1 if ref $arg eq 'Math::BigFloat';
    return 0 if ref $arg;
    my $warning = undef;
    {
        local $SIG{'__WARN__'} = sub { $warning = $_[0] };
        my $tmp = $arg + 0;
    }
    if (defined $warning) {
        if ($warning =~ /numeric/) {
            return 0; # non-numeric
        }
        else {
            warn $warning; # some other warning (?)
            return 0;
        }
    }
    else {
        return 1; # numeric
    }
} # Is_Numeric

# ----------------------------------------------------------------------

sub Is_HMS($) {
    my($word) = @_;

    return $word =~ /^(\d+:)+\d+$/;
} # Is_HMS

# ----------------------------------------------------------------------

sub From_HMS($) {
    my($word) = @_;
    my @fields;
    my $result = 0.0;

    @fields = split /:/, $word;

    for (my $i = $#fields; $i >= 0; $i --) {
        $result += $fields[$i];
        $result /= 60.0 if $i > 0;
    }
    return $result;
} # From_HMS

# ----------------------------------------------------------------------

sub To_HMS($) {
    return "To_HMS not yet implemented";
} # To_HMS

# ----------------------------------------------------------------------

sub Is_Hex($) {
    my($word) = @_;

    return $word =~ /^0x[\da-f]/i;
} # Is_Hex

# ----------------------------------------------------------------------

sub Help() {
    print <<'EOF';
    <number>          : Push a number on the stack
    <num>:<num>...    : Push a number in HH:MM::SS format
    B:<number>        : Push a bignum on the stack (preliminary support)
    +, -, *, /, %, ** : arithmetic operators
    --                : negate
    //                : reciprocal
    %%                : / and %
    & | ^ ~ << >>     : logical operators
    sumn              : sum of top tos stack elements
    dup               : duplicate top of stack (tos)
    drop              : drop tos
    dropn             : drop tos+1 items from stack
    clear             : clear stack
    swap              : swap top two stack elements
    sin, cos, tan, asin, acos, atan :
                        trig functions (radians)
    atan2             : atan(y/x)
    deg               : convert degrees->radians
    exp               : e**x
    ln,  loge         : log base e
    log, log10        : log base 10
    lg,  log2         : log base 2
    int               : integer part (truncate towards 0)
    srand             : set random seed
    srandx            : set random seed to specified value
    rand              : random number
    sqrt              : square root
    vars              : show all variables
    <name>=           : assign variable
    ofmt=             : show output format
    ofmt=<fmt>        : set output format
    .                 : display tos
    hex               : display tos in hex
    octal             : display tos in octal
    hms               : display tos in H:M:S format
    ,                 : dump stack
    Hex               : dump stack in hex
    Octal             : dump stack in octal
    HMS               : dump stack in H:M:S format
    \                 : inhibit stack dump
EOF
#   print "    ...          : continue (used on command line)"
} # Help

# ----------------------------------------------------------------------

sub Check($$) {
    my($word, $count) = @_;

    if ($#stack >= $count) {
        return 1;
    }
    else {
        warn "$word error: too few arguments\n";
        return 0;
    }
} # Check

# ----------------------------------------------------------------------

sub Check_Numeric($$) {
    my($word, $count) = @_;

    if ($#stack >= $count) {
        for (my $i = $#stack; $i >= $#stack - $count + 1; $i --) {
            if (not Is_Numeric $stack[$i]) {
                my $arg = $stack[$i];
                if (ref $arg eq 'SCALAR') {
                    $arg = $$arg;
                }
                warn "$word error: \"$arg\" is non-numeric\n";
                return 0;
            }
        }
        return 1;
    }
    else {
        warn "$word error: too few arguments\n";
        return 0;
    }
} # Check_Numeric

# ----------------------------------------------------------------------

sub Evaluate($) {
    my($word) = @_;
    my $tmp;

    Debug "DEBUG: evaluate \"$word\"\n";

    if ($word eq 'dup') {
        Check $word, 1 and push @stack, $stack[$#stack];
    }

    elsif ($word eq 'drop') {
        Check $word, 1 and pop @stack;
    }

    elsif ($word eq 'dropn') {
        Check_Numeric $word, 1 and do {
            if ($#stack >= $stack[$#stack] + 1) {
                $#stack -= $stack[$#stack] + 1;
            }
            else {
                warn "$word error: too few arguments\n";
            }
        };
    }

    elsif ($word eq 'sumn') {
        Check_Numeric $word, 1 and do {
            if ($#stack >= $stack[$#stack] + 1) {
                my $count = pop @stack;
                my $top_index = $#stack;
                my $bottom_index = $top_index - $count + 1;
                my $result = 0;
                for (my $i = $bottom_index; $i <= $top_index; $i ++) {
                    $result += $stack[$i];
                }
                $#stack -= $count;
                push @stack, $result;
            }
            else {
                warn "$word error: too few arguments\n";
            }
        };
    }

    elsif ($word eq 'clear') {
        $#stack = 0;
    }

    elsif ($word eq 'depth') {
        push @stack, $#stack;
    }

    elsif ($word eq 'swap') {
        Check $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $y;
            push @stack, $x;
        };
    }

    elsif ($word eq '+') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x + $y;
        };
    }

    elsif ($word eq '-') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x - $y;
        };
    }

    elsif ($word eq '*') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x * $y;
        };
    }

    elsif ($word eq '/') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x / $y;
        };
    }

    elsif ($word eq '%') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x % $y;
        };
    }

    elsif ($word eq '**') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, $x ** $y;
        };
    }

    elsif ($word eq '--') {
        Check_Numeric $word, 1 and do {
            my($x) = pop @stack;
            push @stack, - $x;
        }
    }

    elsif ($word eq '//') {
        Check_Numeric $word, 1 and do {
            my($x) = pop @stack;
            push @stack, 1.0 / $x;
        }
    }

    elsif ($word eq '%%') {
        if (Check_Numeric $word, 2) {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, int($x / $y), $x % $y;
        }
    }

    #
    # For logical operators, add 0 to each operand to ensure they
    # operate on numbers, not strings.
    #

    elsif ($word eq '&') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) & (0 + $y);
        }
    }

    elsif ($word eq '|') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) | (0 + $y);
        }
    }

    elsif ($word eq '^') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) ^ (0 + $y);
        }
    }

    elsif ($word eq '~') {
        Check_Numeric $word, 1 and push @stack, ~ (0 + pop @stack);
    }

    elsif ($word eq '<<') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) << (0 + $y);
        }
    }

    elsif ($word eq '>>') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, (0 + $x) >> (0 + $y);
        }
    }

    elsif ($word eq 'sin') {
        Check_Numeric $word, 1 and push @stack, sin pop @stack;
    }

    elsif ($word eq 'cos') {
        Check_Numeric $word, 1 and push @stack, cos pop @stack;
    }

    elsif ($word eq 'tan') {
        Check_Numeric $word, 1 and do {
            my($x) = pop @stack;
            push @stack, sin($x) / cos($x);
        };
    }

    elsif ($word eq 'asin') {
        Check_Numeric $word, 1 and do {
            my($x) = pop @stack;
            push @stack, atan2($x, sqrt(1 - $x**2));
        };
    }

    elsif ($word eq 'acos') {
        Check_Numeric $word, 1 and do {
            my($x) = pop @stack;
            push @stack, atan2(sqrt(1 - $x**2), $x);
        };
    }

    elsif ($word eq 'atan') {
        Check_Numeric $word, 1 and push @stack, atan2(pop @stack, 1.0);
    }

    elsif ($word eq 'atan2') {
        Check_Numeric $word, 2 and do {
            my($y, $x) = (pop @stack, pop @stack);
            push @stack, atan2($x, $y);
        };
    }

    elsif ($word eq 'deg') {
        Check_Numeric $word, 1 and
            push @stack, pop(@stack) * $degrees_to_radians;
    }

    elsif ($word eq 'exp') {
        Check_Numeric $word, 1 and push @stack, exp pop @stack;
    }

    elsif ($word eq 'ln' or $word eq 'loge') {
        Check_Numeric $word, 1 and push @stack, log pop @stack;
    }

    elsif ($word eq 'log' or $word eq 'log10') {
        Check_Numeric $word, 1 and push @stack, log(pop @stack) / log 10.0;
    }

    elsif ($word eq 'lg' or $word eq 'log2') {
        Check_Numeric $word, 1 and push @stack, log(pop @stack) / log 2.0;
    }

    elsif ($word eq 'int') {
        Check_Numeric $word, 1 and push @stack, int pop @stack;
    }

    elsif ($word eq 'srandx') {
        Check_Numeric $word, 1 and srand pop @stack;
    }

    elsif ($word eq 'srand') {
        srand(time^$$);
    }

    elsif ($word eq 'rand') {
        push @stack, rand;
    }

    elsif ($word eq 'randx') {
        Check_Numeric $word, 1 and push @stack, rand pop @stack;
    }

    elsif ($word eq 'sqrt') {
        Check_Numeric $word, 1 and push @stack, sqrt pop @stack;
    }

    elsif ($word eq '!') {
        Check_Numeric $word, 1 and push @stack, Factorial pop @stack;
    }

    elsif ($word eq 'vars') {
        Show_Vars;
    }

    elsif ( $word =~ /^ofmt=$/ ) {
        print qq("output format = "$ofmt"\n);
    }

    elsif ( $word =~ /^ofmt=(.*)$/ ) {
        $ofmt = $1;
    }

    elsif ($word =~ /^([a-zA-Z_]\w*)=$/) {
        my($var_name) = $1;
        if (defined $reserved{$var_name}) {
            print "= error: reserved name\n";
        } else {
            Check $word, 1 and $variables{$var_name} = pop @stack;
        }
    }

    elsif (defined $variables{$word}) {
        push @stack, $variables{$word};
    }

    elsif ($word eq '?' or $word eq 'help') {
        Help;
        $inhibit_dump = 1;
    }

    elsif ($word eq '.') {
        Check $word, 1 and do {
            printf "$ofmt\n", pop @stack;
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'hex') {
        Check_Numeric $word, 1 and do {
            printf "0x%x\n", int $stack[$#stack];
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'octal') {
        Check_Numeric $word, 1 and do {
            #
            # Workaround for mysterious bug, drops '0' and newline
            #
            # print "0", sprintf("%o", int(pop(@stack))), "\n";
            # Commented out workaround; no longer needed
            printf "0%o\n", int $stack[$#stack];
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq 'hms') {
        Check_Numeric $word, 1 and do {
            print To_HMS($stack[$#stack]), "\n";
            $inhibit_dump = 1;
        };
    }

    elsif ($word eq ',') {
        Dump 10;
    }

    elsif ($word eq 'Hex') {
        Dump 16;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'Octal') {
        Dump 8;
    }

    elsif ($word eq 'HMS') {
        Dump 'HMS';
    }

#   else if (word == "...") {
#       Continue = 1
#   }

    elsif ($word eq '\\') {
        $inhibit_dump = 1;
    }

    elsif ($Have_BigFloat and
           De_Comma $word =~ /^[Bb]:\s*(.*)$/ and
           Is_Numeric($tmp = De_Comma $1))
    {
        push @stack, eval 'Math::BigFloat->new($tmp)';
    }

    elsif (Is_Numeric($tmp = De_Comma $word)) {
        push @stack, $tmp;
    }

    elsif (Is_HMS $word) {
        push @stack, From_HMS $word;
    }

    elsif (Is_Hex $word) {
        push @stack, hex $word;
    }

    else {
        # warn "error: unrecognized word $word\n";
        push @stack, \$word;
    }

    if (ref $stack[$#stack] eq 'Math::BigInt') {
        $stack[$#stack] = eval 'new Math::BigFloat $stack[$#stack]';
    }
} # Evaluate

# ----------------------------------------------------------------------

sub Evaluate_String($) {
    my($eval_string) = @_;
    my $result;
    my $warning = undef;

    Debug "DEBUG: \$eval_string = \"$eval_string\"\n";
    {
        local $SIG{'__WARN__'} = sub { $warning = $_[0] };
        {
            no strict;
            $result = eval $eval_string;
        }
        Debug "DEBUG: \$result  = ",  Image($result),  "\n";
        Debug "DEBUG: \$\@       = ", Image($@),       "\n";
        Debug "DEBUG: \$warning = ",  Image($warning), "\n";
        if (defined $warning) {
            $warning =~ s/ at .*$//;
        }
        if (defined $@) {
            $@ =~ s/ at .*$//;
        }
    }
    if (defined $result) {
        if (defined $warning) {
            warn "Warning: $warning\n";
        }
        if (Is_Numeric $result) {
            push @stack, $result;
        }
        else {
            # warn "Result = ", Image($result), " is non-numeric\n";
            push @stack, \$result;
        }
    }
    else {
        if (defined $warning) {
            warn "Warning: $warning\n";
        }
        if (defined $@) {
            warn "Error: $@\n";
        }
    }
} # Evaluate_String

# ----------------------------------------------------------------------

sub Evaluate_Line($) {
    my($line) = @_;
    my $last_arg;
    my $is_eval;

    Debug "DEBUG: evaluate_line \"$line\"\n";
    $inhibit_dump = 0;

    $line =~ s/^\s*//;
    $line =~ s/\s*$//;
    if ($line =~ /^:\s*(.*)$/) {
        $is_eval = 1;
        Evaluate_String $1;
    }
    else {
        $is_eval = 0;
        foreach my $arg (split /\s+/, $line) {
            $last_arg = $arg;
            Debug "DEBUG: calling evaluate \"$arg\"\n";
            Evaluate $arg;
        }
    }
    if ($is_eval or (defined $last_arg and
                     $last_arg ne "," and
                     not $inhibit_dump)) {
        Dump 10;
    }
} # Evaluate_Line

# ----------------------------------------------------------------------

sub Factorial($) {
    my($x) = @_;

    if ($x != int $x) {
        warn "Factorial requires an integer argument\n";
        return $x;
    }
    elsif ($x < 0) {
        warn "Factorial requires a non-negative argument\n";
        return $x;
    }
    else {
        my $result = 1;
        if (ref $x eq 'Math::BigFloat') {
            $result = eval 'Math::BigFloat->new($result)';
        }
        for (my $i = 2; $i <= $x; $i ++) {
            $result *= $i;
        }
        return $result;
    }
} # Factorial

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Opt{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Image($) {
    my($result) = @_;

    if (defined $result) {
        $result =~ s/\n/\\n/g;
        return "\"$result\"";
    }
    else {
        return "undef";
    }
} # Image

# ----------------------------------------------------------------------

sub De_Comma($) {
    my($s) = @_;
    $s =~ s/,//g;
    return $s;
} # De_Comma

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options] [RPN expr]
    -help      : Help
    -debugging : Debugging
Commands:
EOF
    Help;
    exit 1;
} # Usage
