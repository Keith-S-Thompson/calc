#!/user/kst/bin/perl

# $Header: /home/kst/calc/calc,v 1.12 1994-02-04 02:48:02-08 kst Exp $

#
# Currently valid @stack runs from 1 to $#stack inclusive;
# Index 0 is not used (and is set to 'BOTTOM')
#

## sub pop {
##     pop @stack;
## } # end sub pop
## 
## sub push {
##     local($item) = @_;
##     push(@stack, $item);
## } # end sub push

sub dump {
    local($base) = @_;

    local($i);
    local($format);

    ($base == 10) && ($format = "%3d: $#\n");
    ($base == 16) && ($format = "%3d: 0x%x\n");
    ($base ==  8) && ($format = "%3d: 0%o\n");

    if ($#stack) {
	for ($i = 1; $i <= $#stack; $i ++) {
	    # printf("%3d: %s\n", $i, $stack[$i]);
	    printf($format, $i, $stack[$i]);
	}
    }
    else {
	print "  <empty stack>\n";
    }
} # end sub dump

sub show_vars {
    foreach $name (sort keys %variables) {
	printf("%-8s = $#\n", $name, $variables{$name});
    }
} # end sub show_vars

sub numeric {
    local($word) = @_;

    $word =~ /^([+-]?)(\d*)(\.(\d*))?([Ee]([+-]?\d+))?$/ && "$2$4" ne '';
}

sub help {
    print <<'EOF';
    +, -, *, /, %, ** : arithmetic operators
    --                : negate
    //                : reciprocal
    %%                : / and %
    dup               : duplicate top of stack (tos)
    drop              : drop tos
    clear             : clear stack
    swap              : swap top two stack elements
    sin, cos, tan, asin, acos, atan :
                        trig functions (radians)
    atan2             : atan(y/x)
    exp               : e^x
    ln,  loge         : log base e
    log, log10        : log base 10
    lg,  log2         : log base 2
    int               : integer part (truncate towards 0)
    srand             : set random seed
    srandx            : set random seed to specified value
    rand              : random number
    sqrt              : square root
    vars              : show all variables
    <name>=           : assign variable
    ofmt=             : show output format
    ofmt=<fmt>        : set output format
    .                 : display tos
    hex               : display tos in hex
    octal             : display tos in octal
    ,                 : dump stack
    Hex               : dump stack in hex
    Octal             : dump stack in octal
    \\                 : inhibit stack dump
EOF
#   print "    ...          : continue (used on command line)"
} # end sub help

sub check {
    local($count) = @_;

    if ($#stack >= $count) {
	1;
    } else {
	warn "$word error: too few arguments\n";
	0;
    }
}

sub evaluate {
    # local($word) = @_;
    ($word) = @_;	# not local, used by &check

    print "DEBUG: evaluate \"$word\"\n" if $debugging;

    if ($word eq 'dup') {
	&check(1) && push(@stack, $stack[$#stack]);
    }

    elsif ($word eq 'drop') {
	&check(1) && pop @stack;
    }

    elsif ($word eq 'clear') {
	$#stack = 0;
    }

    elsif ($word eq 'depth') {
	push(@stack, $#stack);
    }

    elsif ($word eq 'swap') {
	&check(2) && do {
	    local($temp1, $temp2) = (pop @stack, pop @stack);
	    push(@stack, $temp1);
	    push(@stack, $temp2);
	}
    }

    elsif ($word eq '+') {
	&check(2) && do {
	    push(@stack, pop @stack + pop @stack);
	}
    }

    elsif ($word eq '-') {
	&check(2) && do {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, $x - $y);
	}
    }

    elsif ($word eq '*') {
	&check(2) && do {
	    push(@stack, pop @stack * pop @stack);
	}
    }

    elsif ($word eq '/') {
	&check(2) && do {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, $x / $y);
	}
    }

    elsif ($word eq '%') {
	&check(2) && do {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, $x % $y);
	}
    }

    elsif ($word eq '**') {
	&check(2) && do {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, $x ** $y);
	}
    }

    elsif ($word eq '^') {
	warn "error: use ** for exponentiation\n";
    }

    elsif ($word eq '--') {
	&check(1) && push(@stack, - pop @stack);
    }

    elsif ($word eq '//') {
	&check(1) && push(@stack, 1.0 / pop @stack);
    }

    elsif ($word eq '%%') {
	if (&check(2)) {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, int($x / $y), $x % $y);
	}
    }

    elsif ($word eq 'sin') {
	&check(1) && push(@stack, sin(pop @stack));
    }

    elsif ($word eq 'cos') {
	&check(1) && push(@stack, cos(pop @stack));
    }

    elsif ($word eq 'tan') {
	&check(1) && do {
	    local($x) = pop @stack;
	    push(@stack, sin($x) / cos($x));
	}
    }

    elsif ($word eq 'asin') {
	&check(1) && do {
	    local($x) = pop @stack;
	    push(@stack, atan2($x, sqrt(1 - $x**2)));
	}
    }

    elsif ($word eq 'acos') {
	&check(1) && do {
	    local($x) = pop @stack;
	    push(@stack, atan2(sqrt(1 - $x**2), $x));
	}
    }

    elsif ($word eq 'atan') {
	&check(1) && push(@stack, atan2(pop @stack, 1.0));
    }

    elsif ($word eq 'atan2') {
	&check(2)  && do {
	    local($y, $x) = (pop @stack, pop @stack);
	    push(@stack, atan2($x, $y));
	}
    }

    elsif ($word eq 'exp') {
	&check(1) && push(@stack, exp(pop @stack));
    }

    elsif ($word eq 'ln' || $word eq 'loge') {
	&check(1) && push(@stack, log(pop @stack));
    }

    elsif ($word eq 'log' || $word eq 'log10') {
	&check(1) && push(@stack, log(pop @stack) / log(10.0));
    }

    elsif ($word eq 'lg' || $word eq 'log2') {
	&check(1) && push(@stack, log(pop @stack) / log(2.0));
    }

    elsif ($word eq 'int') {
	&check(1) && push(@stack, int(pop @stack));
    }

    elsif ($word eq 'srandx') {
	&check(1) && srand(pop(@stack));
    }

    elsif ($word eq 'srand') {
	srand(time^$$);
    }

    elsif ($word eq 'rand') {
	push(@stack, rand);
    }

    elsif ($word eq 'randx') {
	&check(1) && push(@stack, rand(pop(@stack)));
    }

    elsif ($word eq 'sqrt') {
	&check(1) && push(@stack, sqrt(pop(@stack)));
    }

    elsif ($word eq 'vars') {
	&show_vars;
    }

    elsif ( $word =~ /^ofmt=$/ ) {
	print "output format = \"$#\"\n";
    }

    elsif ( $word =~ /^ofmt=(.*)$/ ) {
	$# = $1;
    }

    elsif ($word =~ /^(.*)=$/) {
	local($var_name) = $1;
	if (defined $reserved{$var_name}) {
	    print "= error: reserved name\n";
	} else {
	    &check(1) && ($variables{$var_name} = pop(@stack));
	}
    }

    elsif (defined $variables{$word}) {
	push(@stack, $variables{$word});
    }

    elsif ($word eq '?' || $word eq 'help') {
	&help();
	$inhibit_dump = 1;
    }

    elsif ($word eq '.') {
	&check(1) && do {
	    print pop(@stack), "\n";
	    $inhibit_dump = 1;
	}
    }

    elsif ($word eq 'hex') {
	&check(1) && do {
	    printf("0x%x\n", int(pop(@stack)));
	    $inhibit_dump = 1;
	}
    }

    elsif ($word eq 'octal') {
        &check(1) && do {
            #
	    # Mysterious bug, drops '0' and newline
	    #
	    # printf("0%o\n", int(pop(@stack)));
	    print "0", sprintf("%o", int(pop(@stack))), "\n";
            $inhibit_dump = 1;
        }
    }

    elsif ($word eq ',') {
	&dump(10);
    }

    elsif ($word eq 'Hex') {
	&dump(16);
    }

    elsif ($word eq 'Octal') {
	&dump(8);
    }

#   else if (word == "...") {
#       Continue = 1
#   }

    elsif ($word eq '\\') {
	$inhibit_dump = 1;
    }

    elsif (&numeric($word)) {
	push(@stack, $word);
    }

    else {
	print STDERR "error: unrecognized word $word\n";
    }
} #  end sub evaluate

sub evaluate_line {
    local($line) = @_;

    print "DEBUG: evaluate_line \"$line\"\n" if $debugging;
    $inhibit_dump = 0;

    foreach $arg (split(/\s+/, $line)) {
	$last_arg = $arg;
	print "DEBUG: calling evaluate \"$arg\"\n" if $debugging;
	&evaluate($arg);
    }
    if ($last_arg ne "," && ! $inhibit_dump) {
	&dump(10);
    }
}

########################################################################

$debugging = defined $ENV{'DEBUG'};

@stack = ('BOTTOM');

%reserved = ( 'acos',   1,
              'acos',   1,
              'asin',   1,
              'atan',   1,
              'atan2',  1,
              'clear',  1,
              'cos',    1,
              'depth',  1,
              'drop',   1,
              'dup',    1,
              'exp',    1,
              'help',   1,
	      'hex',    1,
	      'Hex',    1,
              'int',    1,
              'ln',     1,
              'log',    1,
	      'octal',  1,
	      'Octal',  1,
              'ofmt',   1,
              'rand',   1,
              'sin',    1,
              'sqrt',   1,
              'srand',  1,
              'srandx', 1,
              'swap',   1,
              'tan',    1,
              'vars',   1 );        

$variables{'pi'} = 3.14159265358979323846;
$variables{'e'}  = 2.71828182845904523536;

$# = '%.16g';

if (@ARGV) {
    &evaluate_line(join(' ', @ARGV));
}  else {
    while (<>) {
	chop;
	&evaluate_line($_);
    }
}
